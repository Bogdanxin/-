[TOC]

# static和final

## 一、static

* 修饰变量：随着类的加载就被初始化，内存中只有一个，jvm只会分配一次内春，所有类共享静态变量。不能修饰局部变量。
* 修饰方法：也是随着类的加载就存在了，不需要依赖任何实例。但是不能被abstract修饰。**static方法可以被重载、继承。但是继承时候不能实现多态**。使用子类访问，优先从子类找，没有再向父类。static不能访问非静态，但是非静态的可以访问静态方法、变量。
* 修饰代码块：在类加载完后，就会执行，而且直执行一次。

## 二、final

* 修饰变量：编译期常量，在程序编译阶段完成初始化；运行时的常量：引用不可变，但是引用的对象内容可变（所以当final修饰的对象被多个线程使用时，也是会发生线程安全问题的）。

* 修饰方法：不能被继承，故不能被子类修改

* 修饰类：不能被继承

* 修饰参数：final类型参数不可变

  **编译期常量：**在程序编译阶段【不需要加载类的字节码】，就可以确定常量的值

  **非编译期常量：**在程序运行阶段【需要加载类的字节码】，可以确定常量的值

## 三、static{}静态代码块和{}非静态代码块

静态代码块在类加载时执行一次，仅此一次

非静态代码块每次new的时候执行

静态代码块-->构造代码块-->构造方法

在实现继承的类被new的过程中，初始化顺序如下：

1. 实现父类的公共静态属性和静态块级代码。

2. 实现自身的静态属性和静态块级代码。

3. 实现父类的非静态属性和非静态代码块。

4. 执行父类的构造函数。

5. 实现自身的非静态属性和非静态代码块。

6. 执行自身的构造函数。

### 提一嘴 子父类构造方法：

子类构造方法中是一定有父类构造方法的，如果子类构造方法中没有显式的展示出，只是表明父类无参构造方法在子类构造方法第一行的``super();``被隐藏了，但都是存在的。而且父类构造方法super一定是在第一行，这也恰好印证了创建实例时，首先调用的是父类构造方法。