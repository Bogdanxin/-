## （必考）浏览器输入一个地址 url。到页面展示中间经历了哪些东西？

1. 浏览器输入一个 url 地址，检查 url 地址是否合法
2. 查看是否有缓存，（浏览器缓存 -> 系统缓存 -> 路由器缓存），如果有则直接显示，没有则继续
3. 查询 DNS 服务器，得到服务器的 ip 地址（DNS 解析）
4. 发送 http 请求前先发送 tcp 请求（三次握手）
5. 握手成功后，浏览器向服务器发送 http 请求
6. 服务器收到请求，返回相应的数据
7. 浏览器收到 http 响应之后根据这个 html 数据构建 dom 树, 在本地窗口渲染并显示网页。且如果此响应可以缓存，则存入缓存。
8. 当浏览器页面被关闭时，终止 HTTP 会话并关闭连接。

## 2.HTTP 中 GET 与 POST 的区别？

[都 2019 年了，还问 GET 和 POST 的区别 ](https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/)

1. GET 从指定的资源请求数据，POST 向指定的资源提交要被处理的数据；
2. GET 请求有长度限制，而 POST 没有；
3. GET 的安全性较差，而 POST 比 GET 更安全（为什么不安全？因为 get 的数据会在 url 显示，会被暴露）
4. GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留；
5. GET 请求能被缓存、收藏为书签，而 POST 不能；
6. GET 请求只能进行 url 编码，而 POST 支持多种编码方式
7. GET 数据在 URL 中对所有人都是可见的，而 POST 数据不会显示在 URL 中；
8. GET 和 POST 本质上就是 TCP 连接，但 GET 产生一个 TCP 数据包，而 POST 产生两个 TCP 数据包。（对于 GET 方式的请求，**浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）。而对于 POST 请求。浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）**）

## 3. 什么是 Http 协议无状态协议? 怎么解决 Http 协议无状态协议?

- 无状态协议对于事务处理没有记忆能力。当客户端一次 HTTP 请求完成以后，客户端再发送一次 HTTP 请求，HTTP 并不知道当前客户端是一个” 老用户 “。
- 可以使用 Cookie 来解决无状态的问题，Cookie 就相当于一个通行证，第一次访问的时候给客户端发送一个 Cookie，当客户端再次来的时候，拿着 Cookie(通行证)，那么服务器就知道这个是” 老用户 “。

## 4. HTTP 优化方案

详细请看：https://blog.csdn.net/gao_yu_long/article/details/79754541
负载均衡技术通过设置虚拟服务器 IP（VIP），将后端多台真实服务器的应用资源虚拟成一台高性能的应用服务器，通过负载均衡算法，将大量来自客户端的应用请求分配到后端的服务器进行处理。负载均衡设备持续的对服务器上的应用状态进行检查，并自动对无效的应用服务器进行隔离，实现了一个简单、扩展性强、可靠性高的应用解决方案。解决了单台服务器处理性能不足，扩展性不够，可靠性较低的问题。

1. TCP 连接复用：TCP 连接复用是将多个客户端的 HTTP 请求复用到一个服务器端 TCP 连接上，而 HTTP 复用则是一个客户端的多个 HTTP 请求通过一个 TCP 连接进行处理。前者是负载均衡设备的独特功能；而后者是 HTTP 1.1 协议所支持的新功能，目前被大多数浏览器所支持。
2. 内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。
3. 压缩：将文本数据进行压缩，减少带宽
4. SSL 加速（SSL Acceleration）：使用 SSL 协议对 HTTP 协议进行加密，在通道内加密并加速
5. TCP 缓冲：通过采用 TCP 缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。
   详细请看：https://blog.csdn.net/gao_yu_long/article/details/79754541

## 5.HTTP 1.0, 1.1, 2.0 的区别

**长短连接**

- HTTP1.1 之后默认支持长连接，如果要断开连接，需要使用 Connection:close; HTTP1.1 节省带宽，默认只发送 header，如果服务器认为客户端有权限进行连接请求服务器，则返回 100， 否则返回 401. 如果客户端接收到 100， 就把 body 传递给服务器。
- HTTP1.1 之前默认短连接，如果需要长连接，要用 connection：keep-alive;

**HTTP1.1 版本新特性**

- 默认持久连接。节省通信量，只要客户端服务端任意一端没有明确提出断开 TCP 连接，就一直保持连接，可以发送多次 HTTP 请求
- 管线化，客户端可以同时发出多个 HTTP 请求，而不用一个个等待响应
- 断点续传，实际上就是利用 HTTP 消息头使用分块传输编码，将实体主体分块传输。

**http2.0**

- http2.0 是二进制
- HTTP 2. 0 多路复用（一个连接可以处理多个请求）
- HTTP2.0 支持 header 压缩，在网络上传输会更快，要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输
- 服务器推送：我们对 HTTP2.0 的服务器进行请求数据的时候， 服务器会顺便把一些客户端需要的资源一起推送到客户端，避免客户端再次创建连接发送请求到服务器获取

## 6. 返回 304 状态码的流程，属于哪一种缓存机制

### 交互流程

1、客户端第一次请求服务端的某个地址时，服务端会在响应时携带 ETag 与 Last-Modified 响应头，
2、客户端下次再发送同一地址的请求时，会携带 If-None-Match 与 If-Modified-Since 请求头，而 If-None-Match 就是 ETag 的值，If-Modified-Since 就是 Last-Modified 的值，
3、这时服务端在接收请求后会获取请求头中的这两个值，然后进行比对，若资源没有更新，则响应 304 状态码，表示请求的资源没有更新，客户端可以从自己的缓存里获取，
4、若资源已更新，则响应 200 状态码，同第一次请求一样，又会在响应时携带新的 ETag 与 Last-Modified 响应头，之后同上逻辑循环。

### ETag 和 If-None-Match

- ETag 是属于 HTTP 1.1 属性，它是由服务器生成返回给前端，说白了，ETag 一般为资源的哈希值，即 ETag 就是服务器生成的一个标记，用来标识资源是否有变化的，且 ETag 的优先级高于 Last-Modified。
- Etag：资源在服务器的唯一标识（生成规则由服务器决定）。Apache 中，ETag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行 Hash 后得到的。
- If-None-Match：当缓存过期时，发现资源具有 Etage 声明，则在请求头带上 If-None-Match（值就是 Etag）。服务器收到请求后发现有头 If-None-Match 则与被请求资源的相应校验串进行比对，决定返回 200 或 304。

## 7. Cookie 和 Session 的区别

[Cookie 与 Session 的区别 ](https://juejin.cn/post/6844903434366222350)

![image-20210111194533341](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20210111194540.png)

![image-20210111194836375](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20210111194836.png)

### 如果用户禁用了 cookie 怎么办呢？

答：使用URL重写的方式，当浏览器第一次请求服务器时候，服务器返回响应，但是发现cookie被禁用了，那么我们只好将想要写入到cookie中的信息暂存在浏览器中，等到浏览器再次请求服务器时候，将暂存信息一并写入到 URL 中，在进行请求，这样就能够代替cookie 进行请求了。![image-20210111195250232](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20210111195250.png)

