**操作系统：**

 

进程：是并发执行的**程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。**

**线程：是进程的一个执行单元，是进程内部的调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。**

**一个程序至少一个进程，一个进程至少一个线程。**

**进程是程序运行的实例。运行一个Java程序的实质就是启动一个java虚拟机进程。进程是程序向操作系统申请资源的基本单位。线程是进程中可独立执行的最小单位。一个进程可以包括多个线程，同一个进程中的所有线程共享该进程的资源。**

**竞态多线程编程中一个问题，对于同样的输入，程序的输出有时是正确的，有时是错误的，这种计算结果的正确性与时间有关的现象被成为竞态。**

**线程安全和非线程安全：** **一个类在单线程环境下能够正常运行，并且在多线程环境下，使用方不做特别处理也能运行正常，我们就称其实线程安全的。反之，一个类在单线程环境下运行正常，而在多线程环境下无法正常运行，这个类就是非线程安全的。**

多线程编程的实质就是将任务的处理方式由串行改为并发。

进程是资源分配最小单位，线程是程序执行的最小单位；进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间。线程是进程的一个实体，一个进程至少有一个线程,同一个进程的所有线程，共享所属进程的资源。

线程占用的资源比进程少很多，所以创建线程和切换线程的开销相对来说很小。但多进程程序更安全，生命力更强。一个进程的死亡不会对其他进程造成影响。而一个线程死掉，（可能会锁住资源）造成整个进程都死掉了。



**多进程和多线程的对比：**

多进程，**每个进程拥有自己的数据，互不干涉**，共享复杂需要IPC，同步简单。占用内存多，切换复杂，CPU利用率低，创建销毁、切换复杂，速度慢，  进程间不会相互影响。 

多线程，**共享所属进程的数据**，共享简单，**同步比较难**。**占用内存少，切换简单**，CPU利用率高，创建销毁、切换简单，速度快，一个线程挂掉将导致整个进程挂掉。

 

**协程：**

**协程**是一种用户态的轻量级线程，**协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈**。协程调度切换时，**将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈**，直接操作栈则**基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。进程线程都是同步机制，而协程则是异步。协程不需要多线程的锁机制。**

 

**进程间通信（IPC，InterProcess Communication）**是指在不同进程之间传播或交换信息。

进程间通信方式：管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等

管道:无名管道, 半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。只能用于父子进程和兄弟进程。

FIFO，也称为命名管道，是一种文件类型。FIFO的通信方式类似于在进程中使用文件来传输数据，只不过**FIFO**类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。可用于任何进程。

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列独立于发送与接收进程。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

信号量（semaphore）与已经介绍过的 IPC 结构不同，**它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。**信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。

**共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。**

 

\1. 管道（pipe）：管道是一种**半双工的通信方式，数据只能单向流动**，而且只能在具有血缘关系的进程间使用。

进程的血缘关系通常指父子进程关系。**管道分为****pipe****（无名管道）和****ﬁ****fo****（命名管道）两种**，有名管道也是半双

工的通信方式，但是它允许无亲缘关系进程间通信。

​    管道是一个**固定大小的缓冲区。在****Linux****中，该缓冲区的大小为****1****页**，即4K字节，使得它的大小不象**文件那样不加检验地增长。从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃****.**

2**.** **信号量（****semophore****）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问**。它通常作为一种锁

机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同

线程之间的同步手段。

\3. **消息队列（****message queue****）：消息队列是由消息组成的链表，存放在内核中** **并由消息队列标识符标识**。消

息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件

接收特定类型的消息。

4**信号（****signal****）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生**。

\5. **共享内存（****shared memory****）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进**

**程创建，但多个进程都可以访问，**共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专

门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。

\6. **套接字（****socke**. **t****）：****socket****，即套接字是一种通信机制，凭借这种机制，客户****/****服务器（即要进行通信的进程）**

**系统的开发工作既可以在本地单机上进行，也可以跨网络进行**。也就是说它可以让不在同一台计算机但通过网

络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。

 

用户态与核心态：

​    防止用户进程访问对操作系统的稳定运行造成破坏。对一些资源的访问进行了等级划分。**内核态和用户态是操作系统的两种运行级别，内核态权限高，用户态权限低。**

​    **操作系统的很多操作会消耗系统的物理资源，**例如创建一个新进程时，要做很多底层的细致工作，如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录、页表等，这些操作显然不能随便让任何程序都可以做，**于是就产生了特权级别的概念，与系统相关的一些特别关键性的操作必须由高级别的程序来完成，这样可以做到集中管理，减少有限资源的访问和使用冲突**

​    **当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为****3****级，是普通的用户进程运行的特权级，**大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的内核**地址空间，**包括代码和数据；**当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为****0****级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。**

​    **用户态和内核态的切换：**

​    **进程大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态**。切换到内核的方式有：**系统调用、发生异常、外围设备的中断。**

 

**进程空间：内核态内存空间、用户态的堆栈（一般8M，从高地址向低地址增长）、数据段、进程代码段、** 

**线程共享的有：进程代码段、进程共有数据、文件描述符、信号处理器、进程当前目录、进程用户ID、进程组ID.**

**线程私有的：线程ID、寄存器的值、线程的栈、线程优先级、错误返回码、线程信号屏蔽码。**

 

线程上下文切换开销：上下文切换的开销包括**直接开销和间接开销**。直接开销有如下几点：

​    操作系统**保存恢复上下文****(CPU****寄存器值，程序计数器值等****)****所需的开销**

​    线程调度器**调度线程的开销**

间接开销有如下几点：

​    处理器**高速缓存重新加载**的开销

​    **上下文切换可能导致整个一级高速缓存中的内容被冲刷**，即被写入到下一级高速缓存或主存

 

 

**线程间的几种通信方式知道不？**

1、**锁机制**

互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。

读写锁：允许多个线程同时读共享数据，而对写操作互斥。

条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行

的。条件变量始终与互斥锁一起使用。

2、**信号量机制**：包括无名线程信号量与有名线程信号量

3、**信号机制**：类似于进程间的信号处理。

**线程间通信的主要目的是用于线程同步**，所以线程没有象进程通信中用于数据交换的通信机制。

 

**死锁条件：互斥、不可剥夺、循环等待、请求与保持。**

 

**分页分段：**

​    传统存储管理方式：作业必须一次全部加载到内存中，方可运行。当作业很大，就无法运行。而且多道作业运行时，内存不足容纳所有作业，导致多道程序性能下降。操作系统引入了虚拟内存的概念，利用计算机的空间局部性和时间局部性原理，将程序分的一部分装入内存运行，其余部分留在外存，等需要的时候再讲外村的程序装入内存继续运行。虚拟内存好像给用户提供了一个比实际内存大得多的存储器。叫，虚拟存储器，大小由计算机地址结构决定。

​    虚拟内存实现方式：请求分页，请求分段，请求段页式存储管理。请求分页存储管理中，将虚拟地址内存空间划分位大小相等的页块，同时内存地址空间，也划分位等大小的页块。系统维持一个页表，存储这虚拟页号到物理快块号的映射。程序中的逻辑地址由两部分组成：页号P和页内位移量W。相邻的页面在内存中不一定相邻，即分配给程序的内存块之间不一定连续。逻辑地址转化为物理地址时，根据页表将页号转化为块号，块号*块大小加上页内偏移得到物理地址。

如果程序执行时，调用到不再内存中的虚拟页面时，发生缺页中断，将页由外村调入内存。如果内存已满，采用页面置换算法将老的淘汰，载入新的。页面置换算法常见的有FIFO,LRU。

优点：没有外碎片，每个内碎片不超过页的大小。

缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。

 

请求分段存储管理：将用户程序地址空间分成若干个大小不等的段，每段能够定义一组相对完整的逻辑信息。存储分配时，以段为单位，段内地址连续，段间不连续。虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。 分页对程序猿而言是不可见的。而分段通常对程序猿而言是可见的，因而分段为组织程序和数据提供了方便。段页式存储组织是分段式和分页式结合的存储组织方法。这样可充分利用分段管理和分页管理的长处。

 

优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。

缺点：会产生碎片。

 

用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。用分页方法来分配和管理实存。

优点：段页式管理是段式管理和页式管理相结合而成，具有两者的优点。

缺点：由于管理软件的增加，复杂性和开销也增加。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。

 

 

操作系统虚拟内存换页的过程

 

 

在进程开始运行之前，不是全部装入页面，而是装入一个或者零个页面，之后根据进程运行的需要，动态装入其他页面；当内存已满，而又需要装入新的页面时，则根据某种算法淘汰某个页面，以便装入新的页面。

 

在使用虚拟页式存储管理时需要在页表中增加一些内容：

**页号、驻留位（中断位）、内存块号、外存地址、访问号、修改位**

**驻留位：表示该页在外存还是内存；**

**访问位：表示该页在内存期间是否被访问过，又称****R****位；**

**修改位：表示该页在内存中是否被修改过，又称****M****位；**

 

缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：

1、保护CPU现场

2、分析中断原因

3、转入缺页中断处理程序进行处理

4、恢复CPU现场，继续执行

 

虚拟内存换页的算法有哪些？

**最优页面置换算法、先进先出页面置换算法（****FIFO****）及其改进、****最近最少使用页面置换算法（****LRU****）、****时钟页面置换算法（****clock****）、最近未使用页面置换算法（****NRU****）****;**

 

换页算法里面，FIFO有什么缺点？怎么改进？

先进先出实现简单，但并没有考虑局部性原理，最近访问过的数据不久之后很可能会再次被访问。性能可能会很差。还会发生Belady异常现象， 使用FIFO算法时，四个页框时缺页次数比三个页框时多。这种奇怪的情况称为Belady异常现象。

称为第二次机会算法。即给每个页面增加一个R位，表示最近访问过，每次先从链表头开始查找，如果R置1位，清除R位并且把该页面节点放到链表结尾；如果R是0，那么就是又老又没用到，替换掉。

 

**进程调度算法：**

**先来先服务调度算法、短作业****(****进程****)****优先调度算法、优先权调度算法的类型、高响应比优先调度算法、时间片轮转法、多级反馈队列调度算法、**

 

 

**线程与协程的区别：**

进程的内存空间是怎么样的？

堆快还是栈快？

​    JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低。

Java的同步机制有哪些：几种锁把。



Java中如果我有两个long数组，想要取他们的交集

Java有没有遇到过fullGC，触发fullGC的条件以及如何排查

网页跳转怎么实现，结合具体的场景 前端

301 和 302 什么区别？结合具体场景

​    301和302都是重定向状态码。说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取。301永久重定向，表示旧地址的资源永久性移除了，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。302临时重定向。表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。

​    网页目录结构调整，网页扩展名调整，网页被移动到一个新的地址，这些都要永久重定向301.

如果网页调整是临时的，之后会调整过来，就用临时重定向302；

504 什么意思？

​    网关超时。

怎么在前端实现网页跳转，用什么函数？

**onclick****跳转**

**设置****window****的****location.href****属性**

  **οnclick="window.location.href='URL'"**

  οnclick="location='URL'"

**调用****window****的****open****方法**

  ο**nclick="window.open('URL','_blank');" //** **在新窗口打开**

  οnclick="window.open('URL','_self');" // 覆盖当前页

**a****标签跳转**

    <a href="URL" target="_blank">Preface</a> // 在新窗口打开

<a href="URL" target="_self">Preface</a> // 覆盖当前页，target属性默认为_self，此处可省略

 

req.getRequestDispatcher("ok.jsp").forward(req,resp)

 

resp.sendRedirect("ok.jsp");//URL发生变化

 

任务处理时间 100ms，服务器 4 核 8G 如何设计线程池达到 1000qps？任务是 90ms 在 IO，10ms 在计算的情况下怎么弄？全在计算呢？

10G 数据，1G 内存，如何快速找到重复出现的数据？

10G 数据，1G 内存，如何快速找到重复出现次数最多的数据？

如何检测跳转页面的登录状态session,cookie

5.java 设计模式， jdk里用到了哪些设计模式。

6.NIO 讲一讲。

不用final还可以用什么办法使得这个类不被继承、

java初始化的顺序

自旋锁 是公平吗？

自旋锁 怎么才能公平。

客户抱怨你们网站太慢，怎么排查问题？

SDS优点，链表、跳表的实现与复杂度

内核态和用户态的切换

select poll epoll三连

虚拟内存的作用

CPU二级缓存

如何快速复用处于TIME_WAIT的连接

三种I/O多路复用

一个TCP报文从本机到对方主机的过程

路由表的结构是什么样的

海量数据(100亿)找最大的100w个数，时间复杂度nlogm，n时100亿，m是100w

衍生出堆排序过程讲一下

redis里几个常用命令？

linux常用命令？

解释XSS 和 CSRF，它们之间有什么区别，以及如何防范。

交换机和路由器区别

17、linux读文件的过程

18、ping 127.0.0.1经过哪些层

19、设置mtu有什么用

Linux 中能否删除一个正在运行的文件

Linux 常用的命令，如何排查 bug

 