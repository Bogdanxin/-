# 缓存预热

## 前置准备工作：

1. 日常例行统计数据访问记录，统计访问频度较高的热点数据
2. 利用LRU数据删除策略，构建数据留存队列

## 准备工作：

1. 将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据
2. 利用分布式多服务器同时进行数据读取，提速数据加载过程

## 实施：

1. 使用脚本程序固定触发数据预热过程
2. 如果条件允许，使用了CDN（内容分发网络），效果更好

## 总结：

缓存预热就是系统启动前，提前将相关数据的缓存数据直接加载到缓存系统中。避免在用户请求时，先查询数据库，然后再将数据缓存缓存的问题。用户直接查询实先被预热的缓存数据。



# 缓存雪崩

问题是：较短时间内，缓存中较多的key集中过期，导致访问大量过期数据时，redis未能命中，从而访问数据库进行获取，数据库无法同时接收大量数据，从而崩溃，进而带来更大的影响

## 解决方案（思路）

1. 更多的页面静态化处理

2. 构建多级缓存架构 如：Nginx缓存+redis缓存+ehcache缓存

3. 检测MySQL严重耗时业务进行优化，如：对数据库瓶颈排查，比如超时查询，耗时较高事务等

4. 灾难预警机制

   监控redis服务器性能指标

   * CPU占用、CPU使用率
   * 内存容量
   * 查询平均响应时间
   * 线程数

5. 限流、降级

   短时间范围内牺牲一个客户体验，限制部分请求访问，降低应用服务器压力

## 解决方案（方法）

1. LRU与LFU切换

2. 数据有效期策略调整

   * 根据业务数据有效期进行分类错峰
   * 过期时间使用固定时间+随机值形式，稀释集中到期的key的数量

3. 超热数据使用永久key

4. 定期维护（自动+人工）

   对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据延时

5. 加锁



# 缓存击穿

问题：

1. Redis某个key过期，该key访问量巨大（高热）
2. 多个数据请求从服务器直接压到Redis后，均未命中
3. redis在短时间内发起大量对数据库中同一数据的访问

## 解决方案（思路）

1. 预先设定：加大此类商品信息key过期时间
2. 现场调整：监控访问量，对自然流量激增的数据延长过期时间或者设置为永久性key
3. 后台刷新数据：启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失
4. 二级缓存：设置不同失效时间 
5. 加锁：分布式锁，防止被击穿，但是有性能瓶颈

## 总结：

缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起大量对同一数据库访问，导致数据库服务器造成压力，从而崩溃。



# 缓存穿透

问题：

1. 获取数据在数据库不存在，数据查询未得到相应数据
2. Redis获取到null数据未进行持久化，直接返回
3. 下次此类数据达到重复上述过程
4. 出现黑客攻击服务器

## 解决方案（思路）

1. 缓存null

2. 白名单策略

   * 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了白名单。加载正常数据时，放行，加载异常数据时，直接拦截（效率低）
   * 使用布隆过滤器

3. 实施监控

   实时监控redis命中率（业务正常范围时，会有一个波动对象）与null数据占比

   * 非活动期间波动：通常检测3-5倍，超过5倍纳入重点排查对象
   * 活动期间波动：通常检测10-50倍，超过50倍纳入重点排查对象

   倍数不同，启动不同排查流程

4. key加密

   问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验

## 总结：

缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致数据库服务器产生压力。



# 性能指标监控

## 监控指标

* 性能指标：Performance

  ![image-20200521104827855](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200521104829.png)

* 内存指标：Memory

  ![image-20200521105131472](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200521105132.png)

* 基本活动指标：Basic activity

  ![image-20200521105252324](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200521105254.png)

* 持久性指标：Persistence

  ![image-20200521105426346](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200521105427.png)

* 错误指标：Error

  ![image-20200521105520890](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200521105522.png)