# 删除策略

## 过期数据

## 数据删除策略

在内存占用与CPU占用之间寻找一种平衡。

### 定时删除

* 创建一个定时器，当key设置有过期时间，而且过期时间达到时，由定时器任务立即执行对键的删除操作
* 优点：节约内存，到时就删除，快速释放不必要的内存
* 缺点：CPU压力大，影响redis响应时间和指令吞吐量

### 惰性删除

* 数据到达过期时间，不做处理，下次访问数据时，如果未过期，返回数据，发现过期，删除，返回不存在
* 优点：节约CPU性能
* 缺点：内存压力大

### 定期删除

* redis启动服务器初始化时，读取配置server.hz的值，默认为10
* 每秒执行server.hz次`serverCron()`，这个方法中再执行`databasesCron()`方法，`databasesCron()`中在执行`activeExpireCycle()`方法。意思是：首先将对服务器进行轮询，每秒轮询server.hz次，然后对服务器中的数据库进行轮询，每个数据库中的expireds都要被轮询一次，进行逐一的检测
* `activeExpireCycle()`对每个expires[*]逐一进行检测，每次执行250ms/server.hz
* 对每个expires[*]检测时，随机挑选W个key进行检测
  1. 如果其中某个key超时，删除key
  2. 如果一轮删除key的数量>W*25%，继续循环该过程
  3. 如果一轮删除key的数量<=W*25%，检查下一个expired[\*]，并不断进行循环。
* <font color="red">注意：检测每一个expires[*]中的语句，是使用的activeExpireCycle方法，而遍历所有的expires[\*]，使用的databasesCorn方法</font>

* 参数current_db用于记录activeExpireCycle()进入哪个expires[\*]执行，比如expires[*]已经执行完了，这个参数就会记录下去

总结：

* 周期性轮询redis库中的时效性数据，采取随机抽取策略，利用过期数据占比的方式控制删除额度
* 特点1：CPU占用设置由峰值，检测频度可自定义设置
* 特点2：内存压力不大，长期占用数据会被持续清理

## 逐出算法

数据删除策略是对应于定时失效的数据，**逐出算法**是对应的所有数据都是一直有效的，而且内存已经满了的情况

### 新数据进入检测

redis受用内存存储数据时，在执行每一个命令前，会调用`freeMemoryIfNeeded()`方法检测内存是否充足，如果内存不满足新加入数据最低要求，redis**要临时删除一些数据为当前指令清理存储空间**。清理空间的策略就成为逐出算法

<font color="red">注意：逐出算法有可能会失败，如果不成功，则反复执行，当对所有数据都尝试完毕后，不能达到清理要求，则将出现错误信息</font>>

### 影响数据逐出的相关配置

* 检测易失数据（可能回过期的数据集server.db[i].expires）
  1. volatile-lru：挑选最近最少使用的数据淘汰（距离当下使用最老的使用数据，多少时间前使用过的数据）
  2. volatile-lfu：挑选最近使用次数最小的数据淘汰（使用次数最小的）
  3. volatile-ttl：挑选将要过期的数据淘汰（按照过期时间）
  4. volatile-rendom：任意选择数据淘汰
* 检测全库数据（所有数据集server.db[i].dict）
  1. allkeys-lru：挑选最近最少使用的数据淘汰
  2. allkeys-lfu：挑选最近使用次数最少的数据淘汰
  3. allkeys-random：任意选择数据淘汰
* 放弃数据逐出
  1. no-enviction：禁止驱逐数据（redis4.0中默认策略），会引发OOM（out of memory）

配置文件：

```
maxmemory-policy 配置策略
```

