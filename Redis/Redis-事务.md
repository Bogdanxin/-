# Redis-事务

## 事务简介

什么是**事务**：事务就是一个命令执行的的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰

## 事务操作

### 基本操作

* 开启事务

  ```
  multi
  ```

  作用

  设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中

* 执行事务

  ```
  exec
  ```

  作用

  设定事务结束位置，同时执行事务。与multi成对出现，成对使用

  <font color="red">注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只执行exec命令后才开始执行</font>

* 取消事务

  事务定义过程中，发生问题就可以使用取消事务

  ```
  discard
  ```

  作用：终止当前事务定义，发生在multi之后，exec之前

### 事务工作流程

![image-20200513150350721](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200513150351.png)

### 事务注意事项

定义事务过程中，命令格式输入错误：

* 语法错误：命令书写格式错误
* 处理结果：如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行，包括那些语法正常的命令

定义事务过程中，命令执行错误：

* 运行错误：命令格式正确，但是无法正确执行，例如对list进行incr操作
* 处理结果：能够正确运行的命令会执行，运行错误的命令不会执行

## 锁

* 对key添加监视锁，在执行exec前如果key发生变化，终止事务执行

  ```
  watch key1 [key2]
  ```

  watch是在multi之前启用，然后只对watch之后的第一个multi和exec监视。

  所以说，这个用途就是将指定一个事务的key进行监视，如果这个key在其他客户端发生改变，就停止事务，exec返回的是nil

* 取消对所有key的监视

  ```
  unwatch
  ```

  <font color="red">注意：multi使用事务时，外部也有其他客户端对事务中的key进行修改，事务结束后，依旧是事务执行后得到的结果，但是如果对某个key加入了锁，在之后的执行事务中也有其他的客户端进行对这个key的操作，这就会导致事务终止执行。也就是说这个事务所有的执行结果消失。</font>

<font size = 3.5>**为什么redis没有锁？**因为加锁会导致其他客户端处于阻塞状态，这样就会导致长时间等待。而这种方式其他客户端无需等待，直接进行操作。操作完成后，执行`WATCH`的客户端会被通知其他客户端执行了其他命令，所以被watch的key没法提交事务，只好重新尝试，类似于CAS操作。</font>

## 分布式锁

* 使用setnx设置一个公共锁

  ````
  setnx lock-key value  // value可以为任意值
  ````

  利用setnx命令的返回值特征，有值则返回设置失败，无值则返回成功

  返回设置成功的，拥有控制权，进行下一步具体操作

  返回设置失败的，不具有控制权，排队或者等待

  操作完毕后通过del操作释放锁

  ```
  del lock-key
  ```

  <font color="red">注意：这里的锁对于多个客户端来说，一定要是一样的，才能够使用锁，进行设置。但是如果其他客户端不通过这个锁进行修改，那么这个就是无效的。</font>

  例如，客户端1使用setnx lock-num 1进行上锁，并且进行相关操作，与此同时，客户端2也请求使用setnx lock-num 1进行操作，但是操作不了。不过，如果此时客户端2直接进行set操作，或者使用另一个锁setnx lock-num1 2操作，也是能够进行修改的

  

* 如果在设置分布式锁之后，该客户端进行操作时出现宕机，使用expire为锁key添加时间限制，到时不释放，直接放弃锁

  ```
  expire lock-key second
  pexpire lock-key milliseconds
  ```

  