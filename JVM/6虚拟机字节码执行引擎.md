# 虚拟机字节码执行引擎

Java虚拟机在执行字节码时候，都会有**解释执行**和**编译执行**两种选择。所有Java虚拟机输入输出一致：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出是执行结果

## 运行时栈帧结构 

“栈帧”支持虚拟机进行方法调用和方法执行的数据结构。存储了方法的**局部变量表**、**操作数栈**、**动态连接**、**方法返回地址**

一个栈帧需要多少分配空间，仅仅取决于程序源码的具体的虚拟机实现的栈内存布局形式。“

”当前栈帧”与“当前方法”相关联，位于栈顶

### 局部变量表

局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量，局部变量表以**变量槽**为最小单位。

每个变量槽保证能存放一个boolean、byte、char、short、int、float、reference、returnAddress类型的数据，这些数据都是32位或更小的内存空间，大于32位，如double和float，都是分配两个连续的变量槽。

由于局部变量表属于线程私有数据，不会引起数据竞争和线程安全问题。

一个方法被调用，Java虚拟机会使用局部变量表完成实参到形参的传递，如果是实例方法，局部变量表中第0位索引的变量槽默认是用于传递方法所属对象的实例引用（this）

局部变量是没有初始化阶段的，如果一个局部变量没有赋初值，无法使用

### 操作数栈

操作数栈最大深度再编译期间就被写入到Code属性的max_stacks中。

方法执行时候，会有数据入栈出栈，即写入、提取栈中内容。

栈中**元素类型**必须要和**字节码指令**序列严格匹配

优化操作：大多数虚拟机会对两个栈帧进行优化处理，两个栈帧出现一部分重叠，让下面栈帧**部分操作数栈**与上面栈帧**部分的局部变量表**重合，这样不仅节约一些空间，还能在进行方法调用时候共用一些数据。无需进行额外的复制传递了。

可以理解位下面栈帧方法调用的是上面的栈帧方法，所以下面栈帧的部分操作数是可以作为上面的栈帧的局部变量的。

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的dongtailianjie

### 方法返回地址

**正常调用完成：**

返回值传递给上层方法调用者，正常返回后，主调方法PC值作为返回地址，栈帧中可能保存这个计数器值。

**异常调用完成：**

返回值无法传递给上传方法调用者，异常无法在方法体中妥善处理。即try-catch没法解决，只能throw。退出时，返回地址是要通过异常处理表确定，栈帧不会保存这些信息。



## 方法调用

方法调用不等同于方法中的代码被执行，唯一任务就是确定被调用方法的版本

### 解析

所有方法调用的目标方法在Class文件里面都是一个常量池中 符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法调用版本在运行期间是不可改变的。即调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来了，这类方法的调用被称为解析

**非虚方法：**静态方法、私有方法、实例构造器、父类方法和被final修饰的方法，其他都是**虚方法**

解析调用一定是静态过程，编译期间都完全确定，在类加载的解析阶段就会把涉及的符号引用转变成明确的直接引用。



### 分派

#### 1. 静态分派（重载）

静态类型和实际类型在程序中都有可能发生变化，区别是**静态类型**变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型在编译期间时可知的；而在**实际类型**的变化结果在运行期间才可以确定，编译器在编译程序时候，并不知道对象的实际类型时什么。

对于**方法重载**，编译器在重载时是通过参数的静态类型而不是实际类型作为判断依据的。由于静态类型在编译器可知，所以在编译阶段，javac编译器就根据参数的静态类型决定了会使用那个重载版本。

所有依赖静态类型来决定方法执行版本的分派动作，都称为**静态分派**，主要应用于方法的重载，静态分派发生在**编译阶段**，通过编译就已经确定了到底是执行哪个版本方法。

静态分派的优先级：

`原数据类型>转型数据类型>该类型的自动装箱类>装箱类的实现接口>父类（优先级由下往上递减）>变长参数`

#### 2. 动态分派（重写）

运行期根据实际类型确定方法执行版本的分派过程称为**动态分派**

`invokevirtual`指令运行解析过程：

1. 找到操作数栈顶第一个元素所指向的对象的**实际类型**，记作C
2. 如果在类型C中找到常量中描述符和简单名称都相符的方法，就进行访问权限校验，如果通过则返回该方法的直接引用，查找结束；不通过校验，则返回异常
3. 如果在C中没有找到，按照继承关系从下往上对父类中的方法进行搜索和验证
4. 如果始终没有找到，就返回异常



例子：

```java
public class Demo1 {

    static class Father {
        public int money = 1;

        public Father() {
            money = 2;
            showMeTheMoney();
        }

        public void showMeTheMoney() {
            System.out.println("i am father, i have $" + money);
        }
    }

    static class Son extends Father {
        public int money = 3;

        public Son() {
            money = 4;
            showMeTheMoney();
        }

        @Override
        public void showMeTheMoney() {
            System.out.println("i am son, i have $" + money);
        }
    }

    public static void main(String[] args) {
        Father guy = new Son();
        System.out.println("this guy has $" + guy.money);
    }
}

结果：
    i am son, i have $0
	i am son, i have $4
	this guy has $2	
```

分析：

`Father guy = new Son();`：

实际类型是Son，但是在调用子类构造方法之前，先隐式调用父类的构造方法，Father构造方法对showMeTheMoney调用时一次虚方法的调用，实际调用的是子类的Son::showMeTheMoney方法，尽管父类的money赋值为4，但是访问的是子类的money，这时初始化为0。

`sout("this guy has $" + guy.money)`:

由于guy是静态类型，静态类型访问到的是Father定义的静态类型的money

#### 3. 单分派和多分派

根据分派基于多少宗量（方法的接收者和方法参数统称为宗量），可以划分为单分派和多分派。

单分派根据一个宗量对目标方法进行选择，多分派则是根据多个宗量对目标方法及逆行选择

Java是静态多分派，动态单分派的语言



## 动态类型语言支持

## 基于栈的字节码解释执行引擎

