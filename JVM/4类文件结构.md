

# Class 类文件结构

Class文件是一组以8个字节为基础单位的二进制流。其格式为伪结构存储数据

伪结构中，有两种数据类型：“无符号数”和“表”。

* 无符号数：属于基本的数据类型，无符号数可以用类描述数字，索引引用，数值量，或者按照UTF-8编码构成的字符串值
* 表：用多个无符号数或者其他表作为数据项的复合数据类型

无论是表还是无符号数，当需要描述多个同类型数量不定的数据时，经常使用一个前置的容器计量器加若干个连续的数据项形式，这时候称这一系列某一类型的数据为某一类型的“集合”

## 魔数和Class文件版本（第1到第8个字节）

每个Class文件头4个字节被称为**魔数**，用来确定这个文件是否为一个虚拟机能否接受的Class文件，其实就是一个文件的识别身份

4个字节过后，就是Class文件的版本号：第5和第6个字节时次版本号，第7第8是主版本号

## 常量池

与Class文件结构中与其他项目关联最多的数据

**容量计数**：由于常量池中的数据数量是不固定的，所以要在常量池中放置一个u2类型数据，代表常量池中的数据个数。但是计数是从1开始，不是从0开始的。

常量池中主要存放两大类常量：字面量、符号引用

Java代码在进行javac编译后，class文件不会保存各个方法、字段在内存中的分布信息，而是通过虚拟机进行解释后，对内存进行分配

常量池中每一项常量都是一个表，一共有17种类型的常量表，每个常量表中第一位是个u1类型的标志位（tag），代表当前常量属于那种常量类型。

## 访问标志

常量池结束后，紧接着的2个字节代表的访问标志（access_flag），这个标志用于识别一些类或者接口层次的**访问信息**

包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类是否定义为final；等等。

## 类索引、父类索引、接口索引集合

**类索引**和**父类索引**都是一个u2类型的数据，而**接口索引集合**是一组u2类型的数据集合，Class文件中由这三项确定该类型的继承关系

类索引用于确定类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引集合用来描述这个类实现了哪些接口，这些实现的接口将按照implements关键字后端接口顺序排列

类索引和父类索引tag之后各自指向类型位CONSTANT_Class_info类描述符常量，再通过CONSTANT_Class_info中的索引值找到CONSTANT_Utf8_info类型的常量中的全限定名字符串。

对于接口索引集合，入口第一项为u2类型的计数器，表示索引表的容量。如果为0，表明索引不再占用任何字节

## 字段表集合

字段表用于描述接口或者类中声明的变量。包括**类级变量和实例级变量**，但不包括在方法中内部声明的局部变量。

访问标志（access_flags）、名称索引（name_index）, 描述符索引（descriptor_index）、属性表集合（attributes）

![image-20200609103608352](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200609103615.png)

* access_flags项目中，存放字段修饰符：字段作用域、static、final等等。使用的是标志位的方法，每个修饰符要么没有，要么有(0或者1)。
* name_index：**对常量池项的引用**，代表着字段的简单名称，指的是没有类型，没有参数修饰的方法名或者字段名称。name_index 存放的是常量池中的一个引用，引用的是这个字段的简单名称。这里的名称既可以是方法的名称还可以是参数的名称。
* descriptor_index：也是**对常量池项的引用**，用来描述字段的数据类型、方法的参数列表（数量、类型、顺序）和返回值。

对于这样一个例子`private int m;`：

access_flags 指的是`private`修饰符，name_index指的是`int`方法和字段描述符（描述符作用就是用来描述字段的数据类型、方法的参数列表、返回值，有基本数据类型、无返回值<指的方法>和对象类型<用L字符加上对象的全限定名称>）

descriptor_index后就是一个属性表集合attribute_info，用于存储一些额外信息，字段表可以在属性表中附加描述0至多项额外信息。如一个常量的值，就可以在属性表中附加。

<font color=red>注：字段表集合中不会列出从父类或者父接口中继承来的字段，但有可能出现原本Java代码中不存在的字段</font>

## 方法表集合

Class文件存储格式中对方法描述与字段描述采用了几乎完全一致的方式。

![image-20200609103608352](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200609103615.png)

例如一个`public static void fun(int a, String str){}`方法：

`public static `修饰符都是在access_flags中，以字节显示；`fun`方法名和`a, str`变量名就是name_index表示，name_index就是指向的常量池中的常量，代表的是方法的名称；descriptor_index就是关于方法的返回值、变量类型符等，也是指向的常量池中的数据：`void  int  String`

Java中方法中的代码在Javac编译成字节码后，存放到属性表中一个名为Code属性中。

<font color=red> 父类方法在子类中没有被重写，方法表集合中不会出现来自父类的方法信息。</font>

## 属性表集合

方法表或者字段表都是有自己的属性表集合的，用来描述一些特定场景

###  Code属性

Java程序里面的代码经过javac编译后，最终变为字节码指令存储在Code属性中。

![image-20200622102709805](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200728143517.png)



* **attribute_name_index**指向CONSTANT_UTF8_info型的常量索引，这个常量固定为”Code“，代表的是该属性的属性名称

* **attribute_length**代表的是属性值的长度，但由于名称索引和代表长度各占了2个和4个字节，所以真正属性长度是要减去6个字节的

* **max_stack** 代表操作数栈深度的大小，虚拟机在运行时，要根据max_stack分配栈帧中的操作数栈深度

* **max_locals** 代表局部变量表所需的存储空间。max_locals单位为变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。长度不小于32bit的数据类型，使用一个Slot，64bit则使用两个。

  **方法参数**（包括实例方法中的this变量）、**显示异常处理程序参数**（try-catch中catch定义的异常参数）、**方法体中定义的局部变量** 都是需要依赖于局部变量表存放。

  虚拟机会将局部变量表中的变量槽进行复用，当代码执行超过一个局部变量作用域时，该变量的槽就可以被其他变量复用。
  
* **code_length和code**都是用来存储Java源程序编译后生成的字节码指令。

<font color=red>Java虚拟机执行字节码应该是基于栈的体系结构</font>

### 其他属性

**Exception属性：**列举出方法种可能抛出的受查异常，也就是方法描述时在throws关键字后面的异常

**LineNumberTable属性：**描述Java源代码行号与字节码行号之间的对应关系

**LocalVariableTable和LocalVariableTypeTable属性：**描述栈帧汇总局部变量表中的变量与Java源码种定义的变量之间关系。

**SourceFile和SourceDebugExtension属性：**SourceFile属性用于记录生成这个class文件的源码文件名，SourceDebugExtension属性用于存储额外代码调试信息

**ConstantValue属性：**通知虚拟机自动为静态变量赋值

**InnerClasses属性：**用于记录内部类与宿主类之间的关系

**Deprecated和Synthetic属性：**Deprecated用于表示某个类、字段、或者方法被原作者不推荐使用

Synthetic代表此字段或者方法并不是Java源码产生而是编译器自行添加的

**StackMapTable属性：**位于code的属性表中，用来提高字节码验证效率

**Signature属性：**

...



