# java内存区域域内存溢出异常

## 运行时数据区域

![image-20200525080136632](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200525080136.png)

### 程序计数器

* 每条线程都需要一个独立程序计数器，每个计数器互不影响，线程私有

* 当前线程所执行的字节码和行号指示器。

* 执行Java方法，计数器记录的是虚拟机字节码指令地址；执行本地方法计数器值就为空。

### Java虚拟机栈

* 线程私有

* 生命周期和线程相同

* 虚拟机栈描述的是Java方法执行的线程内存模型：每个方法执行都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等
* Java虚拟机中的”栈“就是虚机栈，更多是指虚拟机栈中的局部变量表中部分
* 局部变量表中存放：基本类型数据、对象引用、returnAddress类型
* 数据类型在局部变量表中**存储空间以局部变量槽表示**。局部变量表所需空间在编译期间就完成了分配
* 如果线程请求的栈深度大于虚拟机所允许深度，抛出StackOverflowError异常，如果Java虚拟机栈容量可以动态扩展，当栈扩展时，无法申请到足够内存，会抛出OutofMemoryError异常

### 本地方法栈

* 线程私有

* 与虚拟机栈发挥作用基本相同，本地方法栈是为虚拟机用到本地方法服务。
* 深度溢出和拓展失败分别抛出StackOverflowError和OutOfMemoryError异常

### Java堆

* 线程共享，但是可以划分多个线程私有的缓冲区，提升分配时的效率，也是为了提高回收内存效率。
* 存放**对象实例**
* 垃圾收集器管理的内存区域
* Java堆物理上可以是不连续的内存空间，但是逻辑上是连续的
* Java堆中没有内存完成实例分配，并且堆也无法再拓展，抛出OutOfMemoryError异常

### 方法区

* 线程共享

* 存储已被虚拟机加载的类型信息，常量，静态变量即时编译器后的代码缓存等数据

  类型信息：被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

* 方法区可以选择不实现垃圾回收。内存回收的目的是针对常量池的回收和对类型的卸载

* 方法其无法满足新的内存分配需求时，将抛出OutOfMemoryError异常

### 运行时常量池

* 运行时常量池时方法区一部分

### 直接内存

...

## HotSpot虚拟机对象

### 对象的创建

1. 检查：Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。如果没有，必须执行相应类加载过程。

2. 分配内存：对象所需内存大小在加载完成后就可以确定了。分配空间的方式有两个种，**“指针碰撞”和“空闲列表”**。选择哪种分配是由**Java堆是否规整确定的**。是否规整又是由所采用的**垃圾收集器是否带有空间压缩整理**的能力决定的。

   指针碰撞：假设Java堆内存空间绝对规整，分配内存就仅仅时把那个指针向空闲空间挪动一段与对象大小相同的距离。

   空闲列表：Java堆中内存时不规整的，虚拟机就要维护一张表，记录那些空间可用，那些空间不可用。分配空间就是在表中找到一块足够大的区域划分给对象。

3. 分配内存时的线程安全问题：

   * 一种是对分配空间动作进行同步处理

   * 另一种是把内存分配的动作按照线程划分在不同空间中进行，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲区（TLAB）**

     是不是哪个线程干那些活都是确定的？？

4. 初始化：将内存空间（不包括对象头）都初始化为零。如果使用的是TLAB分配内存，初始化可以提前至TLAB中进行。这个保证了对象实例在Java中不赋初值就能直接使用。访问到的值为零。

5. 其他设置：许多设置



如此创建后，虚拟机是已经创建了一个新的对象，但是对于程序来说，并没有对这个对象进行赋值等一系列操作。相对来说，是没有创建的。

### 对象的内存布局

#### 1. 对象头（Header）

对象头包含两个部分：

* “Mark Word”：用于存储自身运行时的数据，哈希码（hashCode）等。但由于对象头中的信息与对象定义数据无关，所以被设计成一个有着动态定义的数据结构
* 类型指针：对象指向他的**类型元数据指针**（？？？），通过这个指针来确定该对象是那个类型。

#### 2. 实例数据

对象真正存储的数据，无论是子类本身就有的数据还是父类继承的数据，都要存储。存储顺序会受到**虚拟机分配策略**和字段在**Java程序中定义顺序**影响

默认分配策略：相同宽度字段会放到一起存放，在此前提下，父类字段会出现在子类之前。子类较窄的变量也会分配在父类变量空隙中。

#### 3. 对齐填充

仅仅起到占位符的作用，HotSpot虚拟机要求自动内存管理系统要求对象起始地址必须是8字节整数倍，所以要用对齐填充补全。



### 对象访问定位

对象的访问方式主流有两种：

1. 使用句柄：

   reference中存储的是稳定句柄地址

   ![image-20200525151739104](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200525151739.png)

2. 直接指针：

   好处就是速度快，节省了一次指针定位的时间开销

   ![image-20200525151841688](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200525165745.png)