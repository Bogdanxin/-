# 内存分配策略

由于Java堆和方法区有着明显的不确定性，所以垃圾收集和内存分配都是对于这两部分的内存。

## 谁被回收？

### 引用计数算法

在对象中添加一个引用计数器，当有一个地方引用他，计数器加一，引用失败，减一，当计数器为0时，对象就是不能在被使用的。即死去

但是会有**循环引用**的现象 

### 可达性分析算法

通过”GC Roots“的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索所走过的路程称为“引用链”，如果某一个对象到GC Roots间没有任何引用链，则这个对象不可能在被使用，被判定可回收对象。

固定可作为GC Roots的对象包括：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用对象
* 所有被同步锁持有的对象
* 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存。

### 引用

JDK1.2 之前的引用：reference类型的数据中存储的数值代表的是另一块内存的起始地址，就表明这个数据代表某块内存、某个对象的引用

JDK1.2之后：分为强引用、软引用、弱引用、虚引用

* **强引用**：最普通的引用赋值，无论所有情况，只要强引用关系还在，垃圾回收器就不会回收被引用的对象

* **软引用**：用来描述一些还有用，但不是必要的对象。对于软引用的对象，**首先第一次垃圾回收，不会进行清理，但是如果这次清理还会发生内存溢出异常，在进行第二次回收，这次就是将软引用对象进行回收**，如果还是没有足够内存，就会抛出内存溢出异常

  引用的对象是软引用，但是表示软引用的引用是强引用这个和下面的弱引用和虚引用都是相同的

* **弱引用**：非必须的对象。弱引用对象只能生存到下一次垃圾收集发生为止。

  软引用和弱引用的垃圾回收：

  软引用当内存空间不足时候，就会将软引用进行回收，弱引用当发生gc，就会将弱引用进行回收

* **虚引用**：这种引用不会对引用对象造成影响。作用只是在引用对象被回收时候收到一个系统通知

  虚引用必须要配合引用队列进行回收。

  有一个例子：当使用一个虚引用引用一个ByteBuffer对象控制直接内存时候，当ByteBuffer对象被GC回收后（没有强引用引用）这时，虚引用就会进入引用队列，通过引用队列讲虚引用对象进行回收，同时回收ByteBuffer控制的直接内存

软引用和弱引用都可以配合一个叫做“引用队列”的队列进行回收，软引用和弱引用都是一个引用对象，当自己引用的对象（就是软引用对象和弱引用对象）被回收后，自己就可以配合引用队列进行对于自身的回收



#### 软引用和弱引用的使用案例：

软引用是将没有必要强引用的对象进行引用。从而在内存不足时，将软引用对象进行回收，而不至于让没有很大用处的引用对象也设置为强引用，使得内存紧张。

**软引用的使用案例：**

```java
public class Solution {

    private static final int _4MB = 4 * 1024 * 1024;

    /**
     * main方法中的作用是：将每个大小为4m的byte数组进行添加，由于设置了jvm内存空间为20m，必会报错oom
     * 而soft方法中，将每个byte数组由SoftReference对象进行引用（软引用），这样一旦内存空间不足，就会将一些软引用进行回收
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        // list --> byte[]
//        List<byte[]> list = new ArrayList<>();
//        for (int i = 0; i < 5; i++) {
//            list.add(new byte[_4MB]);
//        }
//
//        System.in.read();

        soft();
    }

    public static void soft() {

        // list --> softReference --> byte[]
        List<SoftReference<byte[]>> list =  new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            SoftReference<byte[]> ref = new SoftReference<>(new byte[_4MB]);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }

        System.out.println("循环结束:" + list.size());
        for (SoftReference<byte[]> softReference : list) {
            System.out.println(softReference.get());
        }
    }
}

```

由于上面方法中软引用引用对象被清理了，但是软引用对象`SoftReference`还是存在的，所以如何将该对象进行回收，就要引出``引用队列``进行对软引用对象的回收

```java
public class Solution {

    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) throws IOException {
        List<SoftReference<byte[]>> list = new ArrayList<>();

        ReferenceQueue<byte[]> queue = new ReferenceQueue<>();

        for (int i = 0; i < 5; i ++) {
            // 将软引用关联上引用队列，当软引用所引用的对象被回收时，软引用会自动添加到引用队列中
            SoftReference<byte[]> ref = new SoftReference<>(new byte[_4MB], queue);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }

        // 获取引用队列中无用的（没有引用对象的）软引用
        Reference<? extends byte[]> poll = queue.poll();
        // 将无用的软引用在list中进行移除
        while (poll != null) {
            list.remove(poll);
            poll = queue.poll();
        }

        System.out.println("================");
        for (SoftReference<byte[]> ref : list) {
            System.out.println(ref.get());
        }
    }
}
```







### 真正回收

真正进行对象的回收，要进行两次标记

**第一次：**

对象在进行可达性分析算法后，发现这个对象确实没有引用链，进行一次标记

然后进行筛选，条件就是这个对象是否有必要执行`finalize()`方法：如果对象没有覆盖`finalize()`方法，或者`finalize()`方法已经被虚拟机调用过了，就不需要执行`finalize()`方法，**直接回收**

**第二次：**

如果判断为要执行`finalize()`方法，这个对象就会放在F-Queue的队列中，并会被虚拟机创建的优先度低的线程Finalizer执行队列中对象的`finalize()`方法。<font color="red">但是“执行”并不是一定要等到这个`finalize()`方法执行完毕，这样如果某个对象的`finalize()`执行缓慢，会导致队列其他对象回收缓慢，从而系统崩溃</font>

这时，F-Queue队列会将队列中的所有对象进行小规模标记，``finalize()``方法就是对象避免回收的最后机会，只要重新与引用链上的任何对象建立关系即可。譬如将自己（this关键字）赋值给某个类变量或者对象的成员变量即可。这样第二次标记时，它会被移除”即将收回“集合，如果这时的对象也没有赋值，就只能被回收。

注意：任何对象的``finalize()``方法只能被系统调用一次，下一次回收就不会在执行这个方法了，也就是会被马上回收。

### 回收方法区

方法区回收条件苛刻，所以回收成果远低于Java堆

回收主要两部分内容：

1. 废弃常量

   这个常量是否被其他变量引用，没有就可以被回收了

2. 不再使用的类型

   对类的回收条件就非常苛刻

   * 该类的所有实例都被回收，即Java堆中不存在该类以及任何派生类的实例
   * 加载该类的类的加载器已经被回收，通常难以做到
   * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。



在垃圾回收时候，首先要判断的是谁要被回收，这时候就要用到**可达性分析算法**判断对象是否要被回收。之后就是真正回收的``finalize()``方法的判断，最后进行回收。

## 垃圾回收算法

垃圾回收算法分为两类：“引用计数式垃圾收集”、”追寻式垃圾收集“。一般使用追踪式垃圾收集。

### 分代收集理论

1. **弱分代假说**：绝大多数对象都是朝生夕灭的

2. **强分代假说**：熬过多数次垃圾收集过程的对象就越难以消亡

   收集器将Java堆划分为不同区域，根据其年龄（熬过垃圾收集过程的次数）分配到不同区域进行存储

   一个区域大多数对象难以熬过一次收集，所以只关注这些对象中少部分存活下来的对象，能以较低的代价回收到大量空间。另一个区域大多数是难以消亡的对象，这样就能高效率回收这个区域中消亡的对象的空间。

   新生代中，每次垃圾回收时候，都会有大量对象消亡，每次回收少量存活对象，并将这些对象逐步晋升到老年代中

3. **跨代引用假说**：跨代引用相对于同代引用来说仅占极少数

   如果存在跨代引用，是应该更加倾向于两个对象同时生存、同时消亡。例如，新生代和老年代存在跨代引用，老年代难以消亡，则新生代一直引用，则不可能会被回收，继而存活，进而在年龄增长后，晋升到老年代中。

   基于这条假说，我们可以将新生代中建立一个全局数据结构（记忆集），这个结构把老年代划分成若干小块，表示出老年代那一块内存存在跨年引用。当发生Minor GC时，只有包含跨代引用的小块内存的对象才会被加入GC Roots进行扫描

### 标记—清除算法

算法分为两步——标记、清除：首先标记出所有需要回收的对象，在标记完后，统一回收所有标记对象。也可以反过来，首先标记不需要回收的对象，标记完后，统一回收没有标记的对象。标记过程就是判断对象是否属于垃圾的过程。

缺点：

1. 执行效率不稳定。如果是Java堆中的对象大多数是需要清理的，那么标记和清理都会消耗大量资源。
2. 内存碎片化严重。标记、清除后会产生大量碎片。如果分配较大对象会找不到连续的空间而导致进行第二次垃圾收集

![image-20200529103757973](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200529103805.png)

### 标记—复制算法

将内存分为两块，每次只使用其中一块，使用完后，将存活的对象存放到另一块中，这一块的内存进行清理。

**![image-20200529104246768](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200529104246.png)**

**优点：**

1. 降低了内存碎片化
2. 如果存活对象较少，转移效率高，清理效率也高

**缺点：**

1. 空间浪费，只使用了一半的空间
2. 存活对象如果较多，转移效率和清理效率都较低

所以这种算法一般用于新生代。

<font size=3.5>**优化：**</font>

Appel式回收：将新生代中分为一块Eden和两块Survivor区域，每次分配空间就只使用Eden和一块Survivor。进行回收时候，将Survivor和Eden中存活的对象一次性复制到另一个Survivor中，然后直接清理掉Eden和两块Survivor区域中的对象。（Eden 和 Survivor是8:1的比例，每次复制时候，留出一个Survivor为空，标记的放到空Survivor中）

如果Survivor区域空间不够，就要使用到**逃生门**的设计，可以使用其他空间（如老年区）进行分配担保

### 标记—整理算法

标记都是一样的，只是之后的整理都是将标记的对象都移动到内存的一端，然后将要清理掉边界意外的对象

标记—整理算法和标记—清理算法不同，后者为非移动的回收算法，前者为移动的。整理的话，移动会降低效率，不整理的话，碎片化严重，内存分配效率低。

## HotSpot的算法细节实现

### 根节点枚举

固定可作为GC Roots节点主要在**全局性引用**与**执行上下文**

所有收集器在根节点枚举时，都是必须要暂停用户线程的，即在执行枚举期间不会出现根节点集合对象引用关系还在不断变化的情况。

Java虚拟机使用的是**准确式垃圾收集**，HotSpot解决方案里，会使用一组叫做OopMap数据结构来达到目的。一旦类加载动作完成后，HotSpot会把对象内什么偏移量上是什么类型的数据计算下来，在即时编译过程中，也会在特定位置记录下栈里和寄存器哪些位置是引用。

### 安全点

HotSpot无法为每一条指令都生成OopMap，所以只能在“安全点”记录这些信息。有了安全点的设置，决定了用户程序执行时并非在代码指令流的任意位置都能停下来开始垃圾收集，而是强制要求必须执行到达安全点后才能暂停。

安全点位置的选取基本上是以“是否具有**让程序长时间执行**的特征”为标准选定的。长时间执行的最明显特征就是指令序列的复用：例如方法调用、循环跳转、异常跳转等。所以具有这些功能的指令才会产生安全点。

如何在垃圾收集时，将所有线程都跑到最近的安全点？

**分为两种方案：抢先式中断、主动式中断**（多用于主动式）

1. 抢先式中断：不需要线程的执行代码主动配合。发生垃圾收集时，系统首先把用户线程中断，在用户线程中如果发现有中断线程不在安全点上的，就恢复这个线程执行，让他跑到安全点
2. 主动式中断：线程的执行代码主动配合。JVM设置一个标志（安全点），每个线程执行过程中，都会轮询这个标志，一旦发现这个标志为真（说明要中断）时，线程就会跑到最近的安全点主动中断挂起。

### 安全区域

如果线程被停掉等等就会导致该线程无法达到安全点，这时就要设置安全区域。

安全区域指是能够确保在某段代码片段中，引用关系不会发生变化。在这个区域内任何地方开始垃圾收集都是安全的。

安全区域和安全点都是确保在此处不会影响到垃圾回收的根节点枚举，如果想要离开安全区、安全点，必须要等待虚拟机完成枚举才行

### 记忆集与卡表

（？？？？）

记忆集是一种用于记录从**非收集区域**指向**收集区域**的指针集合的抽象数据结构。进行垃圾收集时，只需要通过记忆集判断某块非收集区域是否存在指向了收集区域的指针即可

记录精度：字长精度、对象精度、卡精度

卡精度指的有一种称为“卡表”的方式实现记忆集

### 写屏障

（？？？？）

### 并发的可达性分析

GC Roots节点较少，而且还有OopMap优化，它带来的停顿时间是少的。主要的还是GC Roots向下遍历时要消耗大量时间。

（这里对保障一致性进行图的遍历的解释就在书上看）

这篇[博客](https://www.cnblogs.com/thisiswhy/p/12354864.html)写的不错



# 经典垃圾回收器

<font size = 4 color = "red">**均衡的垃圾收集三大要素：内存占用、吞吐量、延迟**</font>

## Serial收集器

单线程、新生代、客户端

**单线程：**进行垃圾收集时，必须暂停其他所有工作线程直到他收集完成

**客户端：**对于内存小、cpu有限制的客户端，还是有不错的处理能力的

## ParNew 收集器

多线程

**多线程：**就是Serial的多线程模式

## Parallel Scavenge 收集器

多线程、新生代

基于标记-复制算法，能够并行收集

Parallel Scavenge收集器更多关注的是达到可控的吞吐量，让运行用户代码时间尽量占所有运行时间（垃圾收集时间+用户代码时间）的绝大部分。

高吞吐量可以最高效率利用处理器资源。尽快完成运算任务，主要适用于在后台运算而不是需要太多交互的分析任务

## Serial Old 收集器

单线程、老年代、（客户端、服务端）

## Parallel Old 收集器

多线程、老年代、服务端

## CMS 收集器

多线程、服务端

是以**获取最短回收停顿时间**为目标的收集器，**并发收集、低停顿**

### 运行过程：

1. <font size=3.5>**初始标记**</font>

   仅仅标记一下GC Roots能直接关联的对象，速度很快，**要停掉用户线程**

2. <font size=3.5>**并发标记**</font>

   从GC Roots的直接关联对象开始遍历整个对象图，耗时长，但是可以和**用户线程并发运行**

3. <font size=3.5>**重新标记**</font>

   重新标记，为了修正并发标记时，**用户线程并发变动的那一部分对象的标记记录（增量更新）**，这时是要**停掉用户线程**的，耗时要长一些，但是比并发标记要短。

4. <font size=3.5>**并发清理**</font>

   清除标记的已经消亡的对象，可以与**用户线程并发**

### 缺点：

1. 对处理器资源非常敏感：

   因为是要和用户线程并发运行，这就导致两者都会占用一部分资源，用户线程占用多，垃圾收集就会时间变长，垃圾收集占多，用户线程的速度变慢

2. CMS收集器无法处理“浮动垃圾”

   浮动垃圾：

   * 在CMS并发标记和并发清理时，用户线程产生新的对象中，会有一些要消亡的对象，CMS本次无法处理，只好留到下次收集。
   * CMS的增量更新过程中，会有黑色对象（存活的对象）引用消亡对象情况，这里的消亡对象也可以是浮动垃圾，留到下次收集

   由于垃圾收集过程，用户线程要预留足够内存空间

3. 收集结束后，会产生大量碎片

## Garbage First （G1）收集器

它面向堆的任何部分来组成回收集（Collection Set，一般称为CSet）进行回收，衡量标准不是属于那个代，而是**哪块内存存放垃圾多，回收效益最大**，这是G1收集器的Mixed GC模式。

### 区域

G1收集器将连续的Java堆划分成多个**大小相等的独立区域（Region）**，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间。收集器则会对不同Region采用不同的策略去处理。

Region中还有一类特殊的区域（Humongous），专门存储大对象。G1认为只要超过一个Region一般空间的对象就是大对象。对于超过Humongous空间的对象，将会被存放到连续N个Humongous Region之中

### 回收

Region作为最小回收的单元，即每次回收空间都是Region大小的整倍数，避免在整个Java堆中进行全堆 区域回收。

G1收集器去跟踪各个Region里面垃圾堆积的价值大小，后台维护一个优先级列表，每次根据用户设定的收集停顿时间，**优先处理回收价值收益最大的**那些Region。

### 解决问题

* Region里存在跨Region引用的对象如何解决？

  <font color = "red">注意，这里的谁指向谁不明白</font>

  每个Region都维护自己的记忆集，这些记忆集会记录下别的Region指向自己的指针。G1的记忆集存储结构上就是哈希表。key是别的Region的起始地址，Value是一个集合。里面存储的是卡表索引号。

  因为G1的记忆集较其他传统收集器的记忆集更复杂，所以该收集器有着更高的内存负担

* 如何保证收集线程和用户线程互不干扰的运行？

  **对于用户线程改变引用**：G1通过**原始快照（SATB）**算法实现收集线程和用户线程互不干扰。

  **对于回收过程中用户线程创建对象**：G1为每个Region设计两个名为TAMS的指针，把Region中的一部分空间划分出来用于并发回收中，用户线程的对象分配。分配的对象地址都要放到指针中的区域内。这个区域默认里面的对象都是存活的，不用清理。<font color = "red">但是要内存清理速度持平对象分配速度，不然也会引起G1冻结所有的用户线程，进行Full GC</font>

  这里也能看出来，G1是**一边创建对象，一边清理**的收集器

* 如何建立起可靠的停顿预测模型？

  G1收集器停顿预测模型以**衰减均值**为理论基础，衰减均值代表的是“最近的”平均值

### 收集器运行步骤

* <font size=3.5>**初始标记**</font>

  标记GC Roots能够直接关联的对象，修改TAMS指针的值，让下一阶段用户线程并发运行时能够在Region中分配对象，**需要停顿用户线程，耗时短**

* <font size=3.5>**并发标记**</font>

  对堆中的对象进行可达性分析，标记要回收的对象，**耗时较长**，与用户线程并发运行。

* <font size=3.5>**最终标记**</font>

  对**用户线程进行一次短暂的暂停**，处理并发阶段结束后遗留下的少量SATB记录。

  并发标记和最终标记合起来就是**原始快照**的算法

* <font size=3.5>**筛选回收**</font>

  **暂停用户线程**，因为会涉及对存活对象的移动。更新Region统计数据，对各个Region回收价值和成本进行排序。将存活的对象们复制到空的Region中，清理掉旧的Region

### 注意事项

1. 合理分配用户期望停顿时间，使得G1能在不同场景下取得吞吐量和延迟的平衡。
2. G1不是追求一次将堆内存清理干净，而是让清理速度跟得上对象分配速度。一边清理一边分配

## G1和CMS两者比较

同：

​	G1和CMS关注点都是在停顿时间上，对于低延迟还是做的不够

异（写屏障和卡表没弄明白，就先记下来，以后解决）：

1. CMS使用的是标记—清理算法，所以会导致内存碎片化，G1整体上像是使用的标记—整理算法，但是局部上是标记—移动算法，所以内存不会产生碎片
2. 对于内存占用，CMS相对较小。G1和CMS都是用的卡表处理跨代指针。但是G1更为复杂，无论是新生代还是老年代，都必须有一个卡表，这样就会多占用更多的内存；CMS的卡表只是处理老年代到新生代的引用，节省更多内存空间。
3. 执行负载上，CMS相对较小。两者都使用写屏障。CMS使用写后屏障维护卡表；G1使用写后屏障维护（更复杂）卡表，还要为了实现原始快照，使用写前屏障。所以执行负载上也是较大

# 低延迟垃圾收集器

## Shenandoah 收集器

实现在任何内存大小下吧垃圾收集的停顿限制在10ms内，不仅进行并发垃圾标记，还有并发进行对象清理后的整理操作。



### 特点

1. **与G1许多思路上相似**，使用的是Region内存布局，同样也有用于存放大对象的Humongous Region，默认收集策略也是优先处理回收价值最大的Region
2. **支持并发的整理算法**，G1收集时，也能多线程并发，但是是收集线程并发，用户线程是停掉的，而Shenandoah是能够和用户线程并发运行的
3. **默认不使用分代收集**
4. **放弃使用记忆集，改用“连接矩阵”的全局数据结构记录跨Region引用关系**，降低了处理跨代指针的记忆集维护，降低了伪共享问题。

### 工作流程

1. <font size=3.5 >**初始标记**</font>

   标记与GC Roots直接关联的对象，**用户线程停止**，停顿时间与堆大小无关，只与GC Roots对象数量有关

2. <font size=3.5>**并发标记**</font>

   遍历对象图，标记所有可达对象，**用户线程并发运行**，时间长短取决于堆中存活对象数量和对象图复杂程度

3. <font size=3.5>**最终标记**</font>

   处理剩余的SATB扫描，统计出回收价值最高的Region，将这些Region组成一组回收集，**用户线程停止**

4. <font size=3.5>**并发清理**</font>

   清理整个区域中一个存活对象都没有的Region，**用户线程并发运行**

5. <font size=3.5>**并发回收**</font>

   把回收集里存活的对象先 复制一份到其他未被使用的Region中，**用户线程并发运行**。但是由于并发运行，用户线程会在回收线程复制过程中同时对对象进行修改，这样就会导致线程安全问题。于是Shananodoah通过读屏障和“Brooks Pointers”转发指针解决问题。运行时间取决于回收集的大小

6. <font size=3.5>**初始引用更新**</font>

   **引用更新**：把堆中所有指向旧对象的引用修正到复制后的新地址

   但是初始引用更新阶段别没有进行引用更新，而是用来确保**并发回收阶段**中进行的收集线程都已经完成分配给他们的对象移动任务。所以会在此时产生一个**非常短的停顿**（用来等待这些线程？）

7. <font size=3.5>**并发引用更新**</font>

   真正开始进行引用更新，**与用户线程并发**。时间长短取决于内存中涉及的引用数量多少。不需要根据内存图来搜索，而是线性的搜素出引用类型，把旧值改成新值。

8. <font size=3.5>**最终引用更新**</font>

   修正存在于GC Roots中的引用，最后一次**用户线程停顿**，停顿时间至于GC Roots数量有关

9. <font size=3.5>**并发清理**</font>

   并发清理和引用更新后，回收集中所有的Region已经没有了存活对象，最后再调用一次并发清理回收Region空间，供以后的分配对象使用

![image-20200604110419259](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200604110426.png)

> 图中黄色的区域代表的是被选入回收集的Region，绿色部分就代表还存活的对象，蓝色就是用户线程可以用来分配对象的内存Region了。图不仅展示了Shenandoah三个并发阶段的工作过程，还能形象地表示出并发标记阶段如何找出回收对象确定回收集，并发回收阶段如何移动回收集中的存活对象，并发引用更新阶段如何将指向回收集中存活对象的所有引用全部修正，此后回收集便不存在任何引用可达的存活对象了。

### Brooks Pointer (转发指针)

实现对象移动与用户程序并发的解决方案

> 之前的方案为：在被移动对象原有内存设置保护陷阱，一旦用户程序程序访问到归属于旧对象的内存空间就会产生自陷中段，进入预设好的异常处理器，再由其中的代码逻辑把访问转发到复制后的新对象上。由于代价大，就不做使用。

Brooks Pointer是新的方案：在原有对象布局结构对前面统一增加一个新的引用字段，在正常不处于并发移动情况下，该引用指向对象自己。当对象被移动后，Brooks指针会指向移动后的对象，并且，移动后的对象也是有新的Brooks指针。**这一个阶段就是并发回收阶段**，而原位置的Brooks也会**在并发引用更新阶段**被清理掉

![image-20200604113439059](https://raw.githubusercontent.com/Bogdanxin/cloudImage/master/20200604113439.png)

转发指针过程中，有可能出现的问题：

1. **并发写入问题**，不一定保证写操作发生在新复制对象中。如：

   `收集器线程复制了新的副本对象到新的空间-->用户线程更新对象某个字段（这里是原来的对象）-->收集器线程更新转发指针引用值为新的副本地址`

   这就导致更新的是旧对象，而新空间对象没有被更新，之后的指向还是新的对象。

2. **执行效率问题**，没看明白。。。



## ZGC 收集器（ZGC没看懂。。。改天还要再看看）

<font color="red">ZGC收集器是一款基于Region内存分布，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记—整理算法的，以低延迟为首要目标的一款垃圾收集器</font>

### 内存布局

也是使用的Region内存布局，但是ZGC的Region具有动态性——动态创建、销毁和动态的区域大小

* 小型Region：固定容量为2MB，用于放置**多个**小于256KB的小对象
* 中型Region：固定容量为32MB，用于放置大小**多个**大于等于256KB但是小于4MB对象
* 大型Region：容量不固定，可以动态变化。但是必须为2MB的整数倍，用于放置**一个**4MB以上的大对象。注意，大型Region每个空间只放置一个大对象，而且不会被重新分配

### 并发整理算法实现

ZGC使用的是读屏障和染色指针技术

#### 染色指针

收集器进行标记实现时，染色指针直接将**标记信息**记在引用对象的指针上。染色指针将内存中高四位提取出来存储四个标志信息。通过标志信息，① 虚拟机可以直接从指针中看到其引用对象的三色标记状态，② 是否进入重新分配集（即被移动过），③ 是否只能通过`finalize()`方法才能被访问到

染色指针的优势：

* 染色指针可以使得一个某个Region存活对象被移走后，这个Region就可以马上被释放和重用掉，不必等待整个堆中所有指向该Region的引用都被修正后才能被清理。

  相比于Shenandoah需要等到**引用更新阶段**结束后才能释放回收集中的Region；ZGC可以理论上只要有一个空闲空间，就可以进行回收，这就得益于染色指针的“自愈”特性

* 染色指针可以大幅度减少在垃圾收集过程中内存屏障使用数量

* 染色指针可以作为一种可拓展的存储结构用来记录更多与对象标记、重新定位过程相关数据

#### 多重映射（没看懂）

将多个不同的虚拟内存地址映射到同一个物理内存地址上。

### 工作流程

1. <font size=3.5 >**并发标记**</font>

   并发标记是遍历对象图做可达性分析的阶段。**也要经历初始标记和最终标记短暂停顿**。但是ZGC标记不是在对象上，而是会更新染色指针中的Marked0、Marked1标志位

2. <font size=3.5 >**并发预备重分配**</font>

   这个阶段需要根据特定的查询条件统计出本次收集过程中要清理那些Region，将这些Region组成**重分配集**

   ZGC每次回收都会扫描所有的Region，用更大扫描成本换取G1中记忆集的维护成本

   ZGC重分配集只是决定了里面的Region中的存活对象会被重新复制到其他的Region中，然后这个Region会被释放，并不能说明回收行为就只是针对这个集合里的Region进行。

3. <font size=3.5 >**并发重分配**</font>

   这个过程要把重分配集中的存活对象复制到新的Region上。并为重分配集中每个Region维护一个**转发表**，记录从旧对象到新对象的转向关系。

   <font color=red>由于这个转发表，用户线程此时如果并发访问了位于重新分配集上的对象，这次访问就会被与之的内存屏障截获，然后立即根据Region上的装发表将访问转发到新复制的对象上，并同时修正该引用值，使其直接指向新的对象。这就是指针的“自愈”能力</font>

   好处有二：

   1. 只有第一次访问旧对象时候要陷入转发，之后就会都引用新的对象了
   2. 由于染色指针的存在，一旦分配集中某个Region存活对象都复制完毕后，这个Region就可以立即释放，然后用于新对象的分配（但是转发表不会释放），如果其他对象没有更新这个指针，只要有这个转发表，指针就会自愈

4. <font size=3.5 >**并发重映射**</font>

   修正整个堆中指向重分配集中旧对象的所以引用。但是不是必须“迫切”去做的任务。

   重映射清理这些旧引用主要目的为了**不变慢和释放转发表**。不需要一定马上完成。所以，ZGC将并发重映射要做的工作合并到下一次垃圾收集循环中的并发标记中完成了