# 虚拟机类加载机制

## 概述

Java虚拟机吧描述类的数据从class文件中加载到内存中，并对数据进行校验、转换解析和初始化，最红形成可以被虚拟机直接使用Java类型，这个过程被称为**虚拟机的类加载机制**

## 类加载的时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存位置，生命周期如下：

![image-20200714112238019](C:/Users/公维信/AppData/Roaming/Typora/typora-user-images/image-20200714112238019.png)

加载、验证、准备、初始化和卸载五阶段顺序是确定的，但是解析式不一定的，在某种情况下，可以在初始化阶段后再开始，这是为了支持Java的与运行时绑定特性。注意：这些阶段都是户型交叉混合进行的，会在执行过程中调用、激活另一个阶段。

对于“初始化”阶段，严格规定了有且只有6中情况必须执行对类的初始化：

1. 遇到new  getstatic、putstatic、invokestatic这四条字节码指令时，如果类型没有进行初始化，则需要先触发其初始化阶段
   * 使用new关键字实例化对象时候
   * 读取或设置一个类型的静态字段（被final修饰、已在编译期放入常量池的静态字段除外）的时候
   * 调用一个类型的静态方法的时候
2. 使用java.lang.refliect包的方法对类型进行反射调用时候，如果类型没有进行初始化，则需要触发其初始化
3. 初始化类时候，发现其父类没有进行过初始化，需要触发父类的初始化
4. 虚拟机启动时候，用户需要指定一个要执行的主类（包含main方法的那个）虚拟机会先初始化这个主类
5. 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。
6. 当一个接口定义了JDK8新加入的默认方法（被defult关键字修饰的接口方法）时，如果这个接口实现类发生了初始化，那该接口要在其之前被初始化

对于这六种会触发类型进行初始化的场景，称为对一个类型的**主动引用**。除此之外，所有引用类型的方式都不会触发初始化，称为**被动引用**

**被动引用实例1**：**通过子类引用父类静态字段，不会导致子类初始化**，对于静态字段，只有直接定义这个字段的类才会被初始化，通过子类引用父类中定义的静态字段，只会触发父类的初始化，不会触发子类的初始化

```java
public class SuperClass {
    static {
        sout("SuperClass init!");
    }
    
    static int value = 123;
}

public class SubClass extends SuperClass {
    
    static {
        sout("SubClass init!");
    }
    
    
}

public class Test{
    
    psvm() {
        sout(SubClass.value); // 只会打印出SuperClass init和123
    }
}
```

**被动引用实例2**：**通过数组定义引用类，不会触发此类的初始化**，这是因为创建的数组只是在内存空间中开辟了一块空间，并没有对数组中的数据进行存入，所以没有进行初始化。而只有当把数组中数进行存入时候，就会发生初始化。

```java
public class NotInittialization{
    
    psvm() {
        SuperClass[] array = new SuperClass[10];
    }
}
```

**被动引用实例3**：常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会出发定义常量的类的初始化

```java
public class ConstClass {
    
    static {
        
        sout("ConstClass init!");
    }
    
    pubic static final String HELLOWORLD = "hello world!";
}

public class NotInitialization{
    
    psvm() {
        sout(ConstClass.HELLOWORLD);// 只会打印出hello world
    }
}
```

之所以只会打印出hello world，是因为虽然在java源码中确实引用了ConstClass类的常量HELLOWORLD，但是在编译阶段通过**常量传播优化**已经将常量“hello world”直接存储在NotInitialization类的常量池中，以后对其引用，都会转换成对自身常量池的引用

对于接口的初始化过程，不能使用`static{}`语句块，但是编译器依旧会为其生成``<clinit>()``类构造器，用于初始化接口中所定义的成员变量。有一点注意事项：接口初始化时，不要求其父类接口全部完成初始化，只有真正用到父类接口时候，才会初始化（如引用接口中的常量）。

## 类加载的过程

### 加载

加载阶段，Java虚拟机需要完成三件事：

1. 通过一个类全限定名来获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

**对于非数组类加载阶段**，既可以使用Java虚拟机内置的引导类加载器，也可以由用户自定义的类加载器完成

**对于数组类加载阶段**，数组类本身不通过类加载器创建，是由Java虚拟机直接在内存中动态构造出来的，但是数组类的元素类型（Element Type，去掉数组所有维度的类型）最终还是要靠类加载器来完成加载

数组类创建过程遵循以下规则：

* 如果数组的**组件类型**为引用类型，则**递归**采用加载过程去加载该**组件类型**，数组将被标识在加载该组件类型的类加载器的类名称空间上
* 如果数组的组件类型不是引用类型，（如int[] 数组组件类型为int），Java虚拟机将会把数组标记为与引导类加载器关联
* 数组类可访问性和她的组件类型可访问性一致，如果组件类型不是引用类型，他的数组类的可访问性默认为public，柯贝所有类和接口访问到

### 验证

编译器在编译过程中是有检查的，但是Class文件来源是不确定的，所以还是有危险的。

验证阶段分为四个：

1. 文件格式验证

   **目的：验证字节流是否符合Class文件格式规范，并且能被当前版本虚拟机处理。**

   * 是否以魔数0xCAFEBABY开头。

   * 主次版本号是否在当前虚拟机处理范围之内。

   * 常量池的常量中是否有不被支持的常量类型（检查常量的tag标志）。

   * 指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量。

   * CONSTANT_Utf8_info类型的常量中是否有不符合UTF8编码的数据。

   * Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。 
   * ......

   保证输入的二进制字节流能够正确的解析并存储与方法区内。验证过后，字节流会被允许进入Java虚拟机内存方法区进行存储，之后所有的验证阶段都是基于方法区的存储结构进行，不会再对字节流仅从读取、操作了

2. 元数据验证

   **对字节码描述信息进行语义分析，对类的元数据信息进行语义校验**

   * 这个类是否有父类（除了Object,所有的类都应该有父类）。

   * 这个类的父类是否继承了不被允许继承的类（被final修饰的类）。

   * 如果这个类不是抽象类，是否实现了其父类或接口中的要求实现的所有方法。

   * 类中的字段、方法是否和父类产生了矛盾（例如覆盖了父类的final字段）。
   *  ......

3. 字节码验证

   **通过数据流分析和控制流分析，确定语义是合法的、符合逻辑的，该阶段主要是对类的方法体（Class文件中的Code属性）进行分析校验**

   * 操作数栈的数据类型和指令代码序列能配合工作，例如不会出现操作数栈存入了int类型数据，加载时却用long类型。
   * 保证跳转指令（goto）不会跳转到方法体以外的字节码指令上。
   * 保证方法体中的类型转换时有效的。 .
   * .....

   由于不能通过程序准确的判断出程序是否存在bug，而且字节码验证时间消耗过大，所以在JDK6之后将尽可能多的校验辅助措施挪到javac编译器中进行：

   给方法体Code属性的属性表中新添加一项名为“StackMapTable”的新属性，这项属性描述了方法体所有的基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可

4. 符号引用验证

   最后一个阶段校验行为发生在虚拟机将符号引用转化为直接引用时，转换动作将在连接的第三阶段——解析阶段中发生，符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验（该类是否缺少或被禁止访问它依赖的某些外部类、方法、字段等资源）同样需要校验下列内容：

   - 符号引用中通过字符串描述的全限定名是否能找到对应的类。
   - 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
   - 符号引用中的类、字段、方法的访问类型是否可被当前类访问。 ...... 符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用，那么会抛出一个`IncompatibleClassChangeError`异常的子类，例如`NoSuchField(Method)Error`。

对于虚拟机来说，验证阶段是一个重要，但不是必要的阶段，如果你的代码已经被反复使用和验证过了，那么在实施阶段就可以考虑用`-Xverify:none`参数来关闭大部分的类验证措施，以缩短类加载的时间。

### 准备

准备阶段是正式为类中定义的变量（即静态变量）分配内存并设置类变量初始值的阶段

<font color=red>注意： 1. 这时候进行内存分配的仅包括类变量，不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中。2. 通常情况下，初始值是数据的零值，如`public static int valut = 123; `  value在准备阶段初始值为0，此时尚未开始执行任何Java方法，而赋值value为123的动作要到类的初始化阶段才能被执行 3. 在特殊情况下如果类字段属性表中含有ConstantValue属性，在准备阶段变量值就会被初始化为ConstantValue属性（即被final修饰）所指定的初始值</font>

### 解析

Java虚拟机将常量池中的符号引用替换为直接引用的过程。

符号引用和直接引用的关联：

* 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够定位到目标。符号引用与虚拟机实现的内存布局无关，引用的目标不一定是已经加载到虚拟机内存中的内容
* 直接引用：直接引用是可以直接指向目标的指针、相对偏移量、或者是一个能够间接定位到目标的句柄直接引用和虚拟机内存布局直接相关，引用的目标必定在虚拟机内存中存在的

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。

### 初始化

初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序

在准备阶段，变量都会被赋值一次初始零值，在初始化阶段，则根据程序制定的计划去初始化类变量和其他资源，也就是：初始化阶段执行类构造器`<clinit>()`，它是Javac编译器自动生成的。

* `<clinit>()`方法是有编译器自动收集类中的所有**类变量的赋值动作和静态语句块重点语句**合并产生的，收集顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能**访问**到定义在静态语句块之前和之后的变量，只能**赋值**定义在之前的变量
* `<clinit>()`方法与类的构造函数不同，不需要显式的调用父类构造器，Java虚拟机会在子类的`<clinit>()`方法执行之前，保证父类的已经执行完毕。父类的初始化是要早于子类的
* 由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作
* `<clinit>()`方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对静态变量进行赋值操作，编译器可以不生成`<clinit>()`方法
* 接口中不能使用静态语句块，但是仍然有静态变量初始化的赋值操作。执行接口的`<clinit>()`方法，不需要执行父类`<clinit>()`方法，而是只有当父接口中定义的变量被使用时，父类接口才会被初始化
* Java虚拟机必须保证一个类的`<clinit>()`方法在多线程环境下被正确加锁同步。注意，不需要人为加锁，而是jvm会自己帮助加。多个线程同时执行这个类的`<clinit>()`方法，只有一个能执行，其他都阻塞等待

## 类加载器

### 类与类加载器

类加载器只用于实现类的加载动作。对于任意一个类，都必须由加载它的的类加载器和这个类本身一起确定它在Java虚拟机中的唯一性。只有相同类加载器，而且类不相同，才能保证是唯一的一个类，如果类的全限定名相同，但是类加载加载器不同，就是不同的，是两个相互独立的类

### 双亲委派模型

以虚拟机的角度，有两种类加载器：

* 启动类加载器（BootStrap ClassLoader），是由c++实现，是虚拟机一部分
* 其他的所有类加载器，全都由Java实现，继承自java.lang.ClassLoader类

Java一直保持着三层类加载器、双亲委派的类加载架构

**三层类加载器：**

* 启动类加载器：加载存放在`<JAVA_HOME>\lib`目录，或者指定路径下存放的，Java虚拟机能够识别的类库加载到虚拟机种的内存中。
* 扩展类加载器：在类sun.misc.Launcher$ExtClassLoader种以Java代码形式实现的。负责加载`<JAVA_HOME>\lib\ext`目录中，或者被java.ext.dirs系统变量所指定的路径中所有类库。
* 应用程序类加载器：由sun.misc.Lanucher$AppClassLoader实现。负责加载用户路径上的所有类库。一般情况下是程序中默认类加载器。

**双亲委派模型：**

![双亲委派模型](https://upload-images.jianshu.io/upload_images/272719-a38866b72f478795?imageMogr2/auto-orient/strip|imageView2/2/w/1165/format/webp)

除顶端的启动类加载器，其他类加载器都有自己的父类加载器。父子类加载器不是由继承关系实现，而是使用组合关系来复用父类加载器的代码

工作过程：如图所示，一个类加载器收到类加载请求，首先会向父类加载器委派加载任务，如此递归，直到顶端的启动类加载器。所有类的类加载请求都会最终传到启动类加载器中，只有父类无法加载，子类加载器才会尝试加载。

优点就是，Java中的类随着他的类加载器一起具备了一种带有优先级的层次关系。保证一个类在不同环境下都是同一个类

**双亲委派模型代码实现：**

先检查当前类是否被加载过，若没有，调用父类加载器，如果没有父类加载器，就使用默认的启动类加载器。加入父类加载器加载失败，即调用自己的`findClass()`方法加载

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name); //检查该类是否加载过了
            if (c == null) {//没加载过的情况
                long t0 = System.nanoTime();  
                try {
                    if (parent != null) {
                        //如果自定义的类加载器的parent不为null,就调用parent的loadClass进行加载类 
                        c = parent.loadClass(name, false);   
                    } else {
                        //否则就去找bootstrap ClassLoader
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

### 破环双亲委派模型

* 线程上下文类加载器
* OSGi实现模块化热部署

## Java模块化系统

JDK9之后推出的Java模块化系统。为了实现模块化目标——**可配置的封装隔离机制**

* **可配置的封装隔离机制**解决JDK9之前基于类路径来查找以来的可靠性问题
* **可配置的封装隔离机制**还解决了原来路径上跨JAR文件的public类型的可访问性问题，模块提供了更精细的可访问性控制

### 模块的兼容性

JDK9提出与“类路径”相对应的“模块路径”概念，某个类库到底是传统JAR包还是模块，只取决于他存放的路径

模块化系统的三个规则：

* JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。
* 模块在模块路径的访问规则：模块路径下的具名模块（Named Module）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。
* JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。

但是Java模块化系统目前不支持在模块定义中加入版本号来管理约束依赖。

### 模块化下类加载器

1. 扩展类加载器被平台类加载器取代
2. 平台类加载器和应用程序类加载器都不派生子java.net.URLClassLoader
3. 类加载的委派关系也发生变化，平台及应用程序类加载器收到类加载请求，在委派给父加载器前，要先判断该类是否能够归属到某个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载

