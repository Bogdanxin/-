# Java并发包中并发List解析

## CopyOnWriteArrayList

CopyOnWriteArrayList 是线程安全的ArrayList，对其修改都是在底层复制后的一个数组（快照）上进行的，使用了**写时复制策略**

## 解析

### 初始化

* 无参构造函数：

  创建一个大小为0的Object数组作为初始值

* 有参构造函数：

  1. 如果参数是一个数组，直接进行复制
  2. 如果参数是一个集合，将集合中的所有元素复制到本集合

### 添加元素

`add(E e)`为例：

1. 首先获取独占锁，多个线程同时调用时，只有一个线程能够获取到该锁，其他线程阻塞挂起，等待锁的释放
2. 获取到锁的线程会执行复制，将原来的array复制一份到新数组
3. 然后，对新数组添加一个元素
4. 将新数组替换之前的数组
5. 最后释放锁

这就是**写时复制策略**，所有的写操作，都是在复制之后的数组上操作的，并把复制操作后的数组更新为新的集合

### 获取指定位置的元素

`E get(int index)`为例：

1. 首先获取当前集合中的array数组
2. 然后通过下标访问到指定位置的元素

由于整个过程不加锁，线程A在获取到数组后，可能线程B获取独占锁复制新的数组，对新数组写操作，这样集合中的元素就是新数组中的元素了。

但是由于线程A获取的数组还是原来的数组，所以该写操作并没有对其造成影响。线程A获取数据的数组还是原数组。这就是写时赋值策略导致的**弱一致性问题**

**弱一致性：当一个线程正在读取数据时，若此时有另一个线程同时对数据进行修改，读取的线程无法获取到最新数据，即该线程只能读取到读取此时之前的最新数据**

### 修改指定元素

`E set(int index, E element)`为例：

1. 获取独占锁
2. 首先获取当前的数组，并获取当前数组index下标的元素A
3. 对获取元素A和要修改元素B（element）判断是否相同
4. 如果相同，将就将获取到的数组再次赋值到集合中的数组
5. 如果不同，将复制一个新的数组，然后将新数组指定位置index的元素替换成元素B（element），再将新的数组替换为集合中的数组

### 删除元素

`E remove(int index)`为例：

1. 获取独占锁
2. 获取当前数组，并获取数组index下标的元素A
3. 判断当前位置的元素是不是最后一个
4. 如果是，那就表明可以复制从第0和到倒数第二的所有元素到一个数组，只需要一次复制
5. 如果不是，就要复制两次，从第0个到index-1个，从index+1到倒数第一个
6. 然后将新数组替换老数组



### 弱一致性的迭代器

当一个线程对CopyOnWriterArrayList获取迭代器后，其他线程对集合的增删改是不可见的。

1. 获取当前集合中的元素数组，并赋值到迭代器中的名为“快照”（snapshot）的数组中
2. 对该数字进行迭代操作

首先，snapshot是引用的数组，理论上不是快照，不是通过复制获取的元素数组。但是由于进行迭代时候，其他线程会对数组进行写操作，会将元素数组进行复制，并且替换为新的数组。这时候，该snapshot就是一个快照了。所以迭代器迭代元素时候，其他线程对该list不可见